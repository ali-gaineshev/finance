// Express
import { Request, Response } from "express";
// Business Logic
import { saveUser, verifyUser } from "../services/user-service";
import { generateAccessToken, generateRefreshToken } from "../services/util";
// Middleware
import jwt from "jsonwebtoken";
// Enums and types
import { HTTP_CODE, JWT_TOKEN_CREDENTIALS_TYPE, EmailPasswordType } from "@shared/types/common-enums";
import ResponseDTO from "@shared/dto/response";
import { LoginResponse, RefreshResponse } from "@shared/types/common-response";
import { LoginJWTPayload, VerifyUserResponse } from "../types/types";
import { defaultCookieOptions, defaultCookieOptionsWithMaxAge, REFRESH_TOKEN_COOKIE } from "../config/cookie-option";
import { CommonErrorMessage, CommonMessage } from "@shared/types/common-error";
import Config from "../config/config";

class UserController {
  static async register(req: Request, res: Response) {
    // try to register
    try {
      const { email, name, password } = req.body;
      await saveUser(email, name, password);
      res.status(HTTP_CODE.OK).json(
        new ResponseDTO({
          success: true,
          message: "User created successfully",
        }),
      );
    } catch (err: any) {
      // this error value means duplicate user
      const duplication_message = err.errmsg?.includes("E11000");
      res.status(HTTP_CODE.OK).json(
        new ResponseDTO({
          success: false,
          message: CommonErrorMessage.USER_ALREADY_EXISTS,
        }),
      );
    }
    return;
  }

  static async login(req: Request, res: Response) {
    //try to verify login
    const { email, password }: EmailPasswordType = req.body;
    const { isMatch, username, uuid }: VerifyUserResponse = await verifyUser(email, password);
    if (!isMatch) {
      res.status(HTTP_CODE.OK).json(
        new ResponseDTO({
          success: false,
          message: CommonErrorMessage.LOGIN_FAILED,
        }),
      );
      return;
    }

    // Create payload for JWT token
    const payload: LoginJWTPayload = {
      uuid: uuid,
      email: email,
      name: username,
      credentials_flag: JWT_TOKEN_CREDENTIALS_TYPE.LOGIN, // Set a flag to check if token was generated by user credentials or refresh token
    };

    const jwtAccessToken = generateAccessToken(payload);
    const jwtRefreshToken = generateRefreshToken(payload);

    // Set the refresh token in HTTP-only, Secure cookie
    res.cookie(REFRESH_TOKEN_COOKIE, jwtRefreshToken, defaultCookieOptionsWithMaxAge);

    // Send the access token in the response body
    res.status(HTTP_CODE.OK).json(
      new ResponseDTO<LoginResponse>({
        success: true,
        message: CommonMessage.LOGIN_SUCCESS,
        data: {
          token: jwtAccessToken, // Access token is sent in the body for use in subsequent requests
          userState: {
            name: username,
            uuid: uuid,
            email: email,
          },
        },
      }),
    );
  }

  static async refresh_token(req: Request, res: Response) {
    // Check if refresh token exists
    const refreshToken: string | undefined = req.cookies?.refresh_token;

    if (!refreshToken) {
      res.status(HTTP_CODE.UNAUTHORIZED).json(
        new ResponseDTO({
          success: false,
          message: CommonErrorMessage.NO_REFRESH_TOKEN,
        }),
      );
      return;
    }

    try {
      const payload = jwt.verify(refreshToken, Config.REFRESH_TOKEN_SECRET) as LoginJWTPayload;

      const jwtAccessToken = generateAccessToken({
        uuid: payload.uuid,
        email: payload.email,
        name: payload.name,
        credentials_flag: JWT_TOKEN_CREDENTIALS_TYPE.REFRESH,
      });

      // Send the new access token in the response
      res
        .status(HTTP_CODE.OK)
        .json(new ResponseDTO<RefreshResponse>({ success: true, data: { token: jwtAccessToken } }));
    } catch (err: any) {
      res.status(HTTP_CODE.FORBIDDEN).json(
        new ResponseDTO({
          success: false,
          message: CommonErrorMessage.INVALID_CREDENTIALS,
        }),
      );
    }
  }

  static async logout(req: Request, res: Response) {
    res.clearCookie(REFRESH_TOKEN_COOKIE, defaultCookieOptions);

    res.status(200).json(
      new ResponseDTO({
        success: true,
        message: CommonMessage.LOGOUT_SUCCESS,
      }),
    );
  }
}

export default UserController;
